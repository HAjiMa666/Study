---
layout: default
title: JS-高级
category: system
order: 5
---

# JS高级
> 接下来会介绍JS高级部分内容，深入了解JS的重难点

## JS函数this指向

### this的绑定规则
1. 默认绑定
   1. 在浏览器环境下,this直接会绑定window
   2. 在node环境下,this会绑定一个空对象{}
   3. 在严格模式下，指向的是undefined 
2. 隐式绑定
   - 是谁调用普通函数的,就会隐式绑定到上面去,如果是箭头函数的话,他是不接受绑定的,箭头函数中的this会直接继承当前环境的this
3. 显式绑定
   1. 通过`call,apply,bind`进行显示绑定`this`
   2. | call | apply | bind |
      | --- | --- | --- |
      | 传递参数是剩余参数 | 传递参数是数组 | 不传递参数 |
      | 绑定了就会立马执行 | 绑定了就会立马执行 | 只负责绑定,不负责执行 |
      | 每次使用都需要绑定 | 每次都需要绑定 | 只需要绑定一次 |
   3. 如果传递的不是对象，那么会将对应的原始类型转换为包装类型，如果是undefined或者null这种没有包装类型的，会指向window   
4. new绑定
   - 执行过程
     1. 在内存中创建一个空对象
     2. 将该构造函数的prototype属性赋值给该对象的`[[prototype]]`
     3. 将this指向指到当前的对象
     4. 执行构造函数的构造方法,并将值赋值给该对象
     5. 返回新对象

### 内置函数的绑定规则
1. setTimeOut
   - 在此函数内部,是一个独立函数调用,所以在定时器中使用普通函数的话,this的指向是window
2. DOM元素
   - 使用监听事件的时候,this指向的是调用他的DOM元素
3. forEach
   - 在使用该函数的时候,传入的是普通函数的话,没有额外的操作,默认this是window
4. 类似于forEach的高阶函数
   - this在不做任何操作的时候,默认都是独立调用,即默认绑定window
   - 高阶函数是可以传入第二个参数,就是this的绑定,我们可以选择绑定哪个,不确定的话,可以看下IDE工具内的提示
   - 如果是使用的普通函数，那么传入显式绑定的this的时候，可以进行绑定，如果是箭头函数则无法绑定，仍旧绑定window

### this绑定的优先级
1. 显式绑定高于隐式绑定
2. new的绑定高于bind，bind高于apply和call

### this规则之外的一些特殊情况
1. 如果显式绑定遇见null或者undefined的时候,会直接忽略,仍旧保持原来的调用
2. 间接引用
   ```js
    const obj1 = {
      name: 'obj1',
    }

    const obj2 = {
      name: 'obj2',
      foo: function () {
        console.log(this)
      },
    }

    //: 间接函数引用 如果是像下面这种方式调用 则是默认调用 直接绑定window
    ;(obj1.foo = obj2.foo)()

    //:正常来讲 这种应该是属于隐式绑定 this应该指向obj1
    obj1.foo = obj2.foo
    obj1.foo()
   ```
3. 箭头函数
   1. 箭头函数不会绑定**this，arguments**属性
   2. 箭头函数**不能作为构造函数**来使用(不能和new一起来使用,会抛出错误)
